* Create basic parsing for Bomb Jack format sprites/tiles to test the theory


* Output palette sizes debug info


* Warn if a specific tile runs out of colours
    Try to pick the nearest best alternative colour?
    Done> Or automatically strip out the processed pixels and reprocess the tile with any remaining, to create automatic overlays?



* Look for duplicate palettes



* Colour quantize for each tile



* Add char and colour screen output



* Output palettes
    Tests worked quite well: https://twitter.com/MartinPiper/status/1218539634847711232



* Command line options for background and stacked sprite conversions
    Tested with the simulated hardware, working



* Command line parameters: Unify the background and sprite conversion with a single palette pass without pixel output, followed by pixel output, no palette offset for the stacked sprites
    * Looks good, except the first sprite is using palette 3 instead of the correct choice, which is causing a sprite with bright purple
        Look for rejectPalette, it does not seem to be working correctly and picking bright purple even though it doesn't match the forcedColourIndex
        * Was missing currentPaletteIndex++ when rejectPalette was triggered



* Option to learn palettes from one or more input sections before outputting pixels



* outputSprites to be used to output sprite sheet data (4 bytes for hardware) as text file, for automatic inclusion into the TestData2.txt file
    TestImage2.png created to demonstrate the other sprites rendering correctly, including the complex colour sprites test



* --image can set the tile size to be the image size
    Then seting the tile size after --image
    Then --imagequantize can act on the current configured tile size, and optionally handle the whole image
        Using asset mentioned in: https://twitter.com/MonstersGo/status/1196534673675051008
            http://pixeljoint.com/pixelart/31235.htm



* Add ability to squeeze similar palettes until a target number is reached, then add an option that chooses the closest palette without adding new palettes
    * Find the palette with the smallest number of image pixels
    * Find the next closest colour palette
    * If free slots, merge in most used colours from the smallest palette
    * Delete the smallest palette
    * Repeat until the target palette number is reached
    * Well that (--palettequantize and --fitpalettes) (in run config "Main old bridge RGB 0 0 0 palette opt") did not work as well as expected
    * Why? :)
    * The "visualisePalettes" seem to be reasonable after palette quantise. So maybe it's the tile choice that picks the best palette?
        * Perhaps: MPi: TODO: While this uses the single set of "used colours" a better approach might be to calculate the total distance for all pixels in the tile
            * Yes, this fixed it: // This calculates the total distance for all pixels in the tile using the closest matched colour for the palette
            * Also useSquaredModel = true seems to produce a better result with the "flag" in the top right and some other small details near the bottom of the screen



* RGB Colour multiplier, for the number of pixels, with a floating point number
    Designed to preserve colours by increasing the number of pixels the algorithm uses internally
    --rgbfactor 236 98 96 50 is enough to preserve the flag colouring and some additional red coloured elements

	
	
* Output raw pixels as bytes, not bitplanes, make it possible to use any colours from anywhere within the specified palette.
    This can be used for the mode7 data
    * Run/Debug Configuration: Main mode7
        TODO: // Advances the tile number, could do with duplicate check here
        TODO: Use mode7 screen width/height size for input data
	* Existing sprite/tile data also works for TestData2.txt with the number of tiles reduced.



* ImageToBitplane is outputting the wrong palette index for the sprite sheet, but the original palette values in GenerateData2 are working?
	The currentTile tile index looks to be out by 1????

	
	
* Have the option, for mode7, to support loading sparse palettes and then taking into account the forced colour(s) use the spaces for extra colours
	Then output new palettes.




* Character screen conversion for: oldbridge cropped_chars.bmp
	Config: oldbridge char screen
	* Added indexPick8_8 choice
	* Done - Load into a unit test feature file, with just the char screen plane enabled.
		BDD6502\features\TestVideoHardware Chars.feature
		Best cofnig to use is: oldbridge char screen with rgbfactor
	* Needs to cope with extra character indexes (lower 2 bits of the upper colour nybble) since: num tiles=820
		Add command line flag

* // TODO: Chars will need to be handled, for their chosen palette range




* Add option to specify multiple rectangle areas and search for the best X/Y pixel offsets within those areas to get the optimal empty tile packing
	Sprite sections with position search
	Extracted main tile conversion to cli.Main.processTileImageAt()
		All demos work
	Change two for loops to use computed list of coordinates, or coordinates from command line
	If using coordinates from command line, the larger area can be shifted in its bounding box
		This would need to take into account transparent pixels, those that match forcedColourIndexTransparent
	Use text identifier for each coordinate input
	* Done: Only output a new sprite "EmitSpriteFramered*" if it's the start of a region
		Otherwise output x/y offset values for the +MEmitSpriteFrame
		No need for: region.name + "_" + Integer.toString(xs) + "_" + Integer.toString(ys);
	// Done: If region optimisation is enabled, move the region to the top left to the transparent colour rules
		Output the sprite offset combined into the rest of the region
