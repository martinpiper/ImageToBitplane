* Add option to specify multiple rectangle areas and search for the best X/Y pixel offsets within those areas to get the optimal empty tile packing
	Sprite sections with position search
	Extracted main tile conversion to cli.Main.processTileImageAt()
		All demos work
	Change two for loops to use computed list of coordinates, or coordinates from command line
	If using coordinates from command line, the larger area can be shifted in its bounding box
		This would need to take into account transparent pixels, those that match forcedColourIndexTransparent
	Use text identifier for each coordinate input
	* Done: Only output a new sprite "EmitSpriteFramered*" if it's the start of a region
		Otherwise output x/y offset values for the +MEmitSpriteFrame
		No need for: region.name + "_" + Integer.toString(xs) + "_" + Integer.toString(ys);
	// TODO: If region optimisation is enabled, move the region to the top left to the transparent colour rules
		Output the sprite offset combined into the rest of the region




* Option to favour palette creation from existing char/tile/sprite definition.
	This is useful for re-use of an existing char/tile/sprite as a shadow or silhouette.
	Steps:
	Note char shape, being careful to preserve any forced colours
		This means a character like this, where 0 is forced to be index 0:
			00001234
			00000123
			00000012
			00000001
			00000000
			01241230
			00000000
			00000000
		Can be mapped to be the same as this character which is intended to be its "shadow":
			00001111
			00000111
			00000011
			00000001
			00000000
			01111110
			00000000
			00000000
	Spot duplicate, taking into account any flips
	Just create a new palette containing 4 black colours to cover the entire range of the colour indexes in the original definition
	* Note: To facilitate the process, it may be required to sort the definitions to process in descending order of complexity
		This means counting the number of distinct used colours for a definition and processing those first



* Option to ignore forced index 0 pixels at input, makes them transparent



* // TODO: palette = (HashMap<Integer, Integer>) forcedColourIndex.clone();
    Palette loading will need to enforce the palette size groups based on the original palette
	
	
	
* To improve duplicate character and flips detection, try permutations of output planes and *once only* reorganise the palette.
	Or do not sort colours in palettes, this will preserve the ordering and weighting of pixels detected in chars.
	This will need some carefully created test data to exercise these cases.



* Try the full "old bridge" in mode7 with full 256 colour palette and index 0=0,0,0



* Tidy code and unit test



* Detect identical output tile data, with H/V flips, from the output binary point of view and avoid
    Instead use the original index for screen output



* Make the inputs and outputs configurable via a text config file, with includes
